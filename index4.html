<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Driving Tour Guide</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .animate-pulse {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
    </style>
</head>
<body class="bg-gradient-to-b from-blue-50 to-blue-100 min-h-screen">
    <div class="p-4">
        <div class="max-w-md mx-auto">
            <div class="bg-white rounded-lg shadow-lg p-6 mb-4">
                <div class="flex items-center justify-center mb-6">
                    <svg class="w-8 h-8 text-blue-600 mr-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7"/>
                    </svg>
                    <h1 class="text-2xl font-bold text-gray-800">Driving Tour Guide</h1>
                </div>
                
                <div class="mb-6">
                    <div class="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-4">
                        <p class="text-sm text-blue-800 font-medium mb-2">Status:</p>
                        <p class="text-blue-900" id="status">Ready to start</p>
                        <p class="text-xs text-blue-700 mt-2" id="debugInfo"></p>
                    </div>
                    
                    <div id="locationDiv" class="bg-gray-50 border border-gray-200 rounded-lg p-4 mb-4 hidden">
                        <p class="text-sm text-gray-600 mb-1">Current Location:</p>
                        <p class="text-xs font-mono text-gray-700" id="location"></p>
                        <p class="text-xs text-gray-600 mt-1">Heading: <span id="heading">N/A</span></p>
                    </div>
                    
                    <div id="speakingDiv" class="flex items-center justify-center bg-green-50 border border-green-200 rounded-lg p-3 mb-4 hidden">
                        <svg class="w-5 h-5 text-green-600 mr-2 animate-pulse" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z"/>
                        </svg>
                        <p class="text-green-800 font-medium">Speaking...</p>
                    </div>
                    
                    <div class="bg-amber-50 border border-amber-200 rounded-lg p-4 mb-4">
                        <p class="text-sm text-amber-800 mb-1">
                            <strong>Places announced:</strong> <span id="placeCount">0</span>
                        </p>
                        <p class="text-xs text-amber-700 mt-1">
                            <strong>Places found nearby:</strong> <span id="foundCount">0</span>
                        </p>
                        <p class="text-xs text-amber-700 mt-1">
                            <strong>Current radius:</strong> <span id="currentRadius">N/A</span>
                        </p>
                        <p class="text-xs text-amber-700 mt-1">
                            <strong>Last check:</strong> <span id="lastCheck">Never</span>
                        </p>
                        <p class="text-xs text-amber-700 mt-1">
                            <strong>Last source:</strong> <span id="lastSource">N/A</span>
                        </p>
                    </div>
                    
                    <div id="recentAnnouncements" class="bg-purple-50 border border-purple-200 rounded-lg p-4 mb-4 hidden">
                        <p class="text-sm font-bold text-purple-800 mb-2">Recent Announcements:</p>
                        <div id="announcementList" class="text-xs text-purple-700 space-y-1 max-h-40 overflow-y-auto"></div>
                    </div>
                    
                    <div id="debugLog" class="bg-gray-50 border border-gray-300 rounded-lg p-3 mb-4 hidden">
                        <p class="text-xs font-bold text-gray-700 mb-1">Debug Log:</p>
                        <div id="debugMessages" class="text-xs text-gray-600 space-y-1 max-h-32 overflow-y-auto"></div>
                    </div>
                </div>
                
                <button id="startBtn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-4 px-6 rounded-lg flex items-center justify-center transition-colors mb-3">
                    <svg class="w-6 h-6 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"/>
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
                    </svg>
                    Start Journey
                </button>

                <button id="checkBtn" class="w-full bg-green-600 hover:bg-green-700 text-white font-semibold py-3 px-6 rounded-lg items-center justify-center transition-colors mb-3 hidden">
                    <svg class="w-5 h-5 mr-2 inline" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/>
                    </svg>
                    Check Now
                </button>
                
                <button id="stopBtn" class="w-full bg-red-600 hover:bg-red-700 text-white font-semibold py-4 px-6 rounded-lg items-center justify-center transition-colors hidden">
                    <svg class="w-6 h-6 mr-2 inline" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 10a1 1 0 011-1h4a1 1 0 011 1v4a1 1 0 01-1 1h-4a1 1 0 01-1-1v-4z"/>
                    </svg>
                    Stop Journey
                </button>
            </div>
            
            <div class="bg-white rounded-lg shadow-lg p-6">
                <h2 class="text-lg font-bold text-gray-800 mb-3">Instructions</h2>
                <ol class="text-sm text-gray-700 space-y-2">
                    <li>1. Connect your phone to your car via Bluetooth</li>
                    <li>2. Make sure your phone volume is turned up</li>
                    <li>3. Press "Start Journey" before you begin driving</li>
                    <li>4. Place your phone safely and keep it charging</li>
                    <li>5. The app will announce nearby historical places automatically</li>
                    <li>6. Use "Check Now" button to manually search for places</li>
                    <li>7. Press "Stop Journey" when you arrive</li>
                </ol>
                
                <div class="mt-4 bg-yellow-50 border border-yellow-200 rounded-lg p-3">
                    <p class="text-xs text-yellow-800">
                        <strong>Note:</strong> This app needs location permissions and internet connection. It works best with the phone plugged in to save battery. The app adapts its search radius based on area density.
                    </p>
                </div>
            </div>
        </div>
    </div>

    <script>
        let isActive = false;
        let watchId = null;
        let announcedPlaces = new Set();
        let lastCheckTime = 0;
        let isSpeaking = false;
        let speechQueue = [];
        let isProcessing = false;
        let currentLat = null;
        let currentLon = null;
        let currentHeading = null;

        const statusEl = document.getElementById('status');
        const debugInfoEl = document.getElementById('debugInfo');
        const locationEl = document.getElementById('location');
        const headingEl = document.getElementById('heading');
        const locationDiv = document.getElementById('locationDiv');
        const speakingDiv = document.getElementById('speakingDiv');
        const placeCountEl = document.getElementById('placeCount');
        const foundCountEl = document.getElementById('foundCount');
        const currentRadiusEl = document.getElementById('currentRadius');
        const lastCheckEl = document.getElementById('lastCheck');
        const lastSourceEl = document.getElementById('lastSource');
        const recentAnnouncementsDiv = document.getElementById('recentAnnouncements');
        const announcementListEl = document.getElementById('announcementList');
        const debugLogDiv = document.getElementById('debugLog');
        const debugMessagesEl = document.getElementById('debugMessages');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const checkBtn = document.getElementById('checkBtn');

        function addAnnouncement(placeName, source) {
            const sourceLabel = source === 'historic_england' ? 'Historic England' : 'Wikipedia';
            const sourceColor = source === 'historic_england' ? 'text-blue-700' : 'text-green-700';
            
            const timestamp = new Date().toLocaleTimeString();
            const item = document.createElement('div');
            item.className = 'border-b border-purple-200 pb-1 mb-1';
            item.innerHTML = `<span class="font-medium">${placeName}</span> <span class="${sourceColor}">[${sourceLabel}]</span> <span class="text-gray-500">- ${timestamp}</span>`;
            
            announcementListEl.insertBefore(item, announcementListEl.firstChild);
            recentAnnouncementsDiv.classList.remove('hidden');
            
            lastSourceEl.textContent = sourceLabel;
            
            // Keep only last 5 announcements
            while (announcementListEl.children.length > 5) {
                announcementListEl.removeChild(announcementListEl.lastChild);
            }
        }

        function addDebugMessage(msg) {
            const timestamp = new Date().toLocaleTimeString();
            const msgEl = document.createElement('div');
            msgEl.textContent = `[${timestamp}] ${msg}`;
            debugMessagesEl.insertBefore(msgEl, debugMessagesEl.firstChild);
            debugLogDiv.classList.remove('hidden');
            console.log(msg);
            
            while (debugMessagesEl.children.length > 10) {
                debugMessagesEl.removeChild(debugMessagesEl.lastChild);
            }
        }

        function setStatus(msg, debug = '') {
            statusEl.textContent = msg;
            debugInfoEl.textContent = debug;
            console.log('Status:', msg, debug);
        }

        function speak(text) {
            return new Promise((resolve) => {
                // Add natural pauses
                const naturalText = text
                    .replace(/\. /g, '... ')  // Longer pause after sentences
                    .replace(/, /g, ',, ');    // Pause after commas
                
                const utterance = new SpeechSynthesisUtterance(naturalText);
                utterance.rate = 0.85;  // Slightly slower for clarity
                utterance.pitch = 1.05;  // Slightly higher pitch sounds more natural
                utterance.volume = 1;
                
                // Try to select a better voice if available
                const voices = window.speechSynthesis.getVoices();
                const preferredVoices = voices.filter(v => 
                    v.lang.startsWith('en') && 
                    (v.name.includes('Google') || v.name.includes('Natural') || v.name.includes('Enhanced'))
                );
                if (preferredVoices.length > 0) {
                    utterance.voice = preferredVoices[0];
                } else if (voices.length > 0) {
                    const enVoice = voices.find(v => v.lang.startsWith('en-GB')) || 
                                   voices.find(v => v.lang.startsWith('en'));
                    if (enVoice) utterance.voice = enVoice;
                }
                
                utterance.onstart = () => {
                    console.log('Started speaking:', text.substring(0, 50));
                };
                
                utterance.onend = () => {
                    console.log('Finished speaking');
                    isSpeaking = false;
                    speakingDiv.classList.add('hidden');
                    resolve();
                };
                
                utterance.onerror = (e) => {
                    console.error('Speech error:', e);
                    isSpeaking = false;
                    speakingDiv.classList.add('hidden');
                    resolve();
                };
                
                isSpeaking = true;
                speakingDiv.classList.remove('hidden');
                window.speechSynthesis.cancel();
                
                // Ensure voices are loaded
                if (voices.length === 0) {
                    window.speechSynthesis.onvoiceschanged = () => {
                        window.speechSynthesis.speak(utterance);
                    };
                } else {
                    window.speechSynthesis.speak(utterance);
                }
            });
        }

        async function processSpeechQueue() {
            if (isProcessing || speechQueue.length === 0) {
                return;
            }
            
            isProcessing = true;
            
            while (speechQueue.length > 0) {
                const text = speechQueue.shift();
                await speak(text);
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
            
            isProcessing = false;
        }

        function addToSpeechQueue(text) {
            console.log('Adding to speech queue:', text.substring(0, 50));
            speechQueue.push(text);
            processSpeechQueue();
        }

        // Calculate bearing between two points
        function calculateBearing(lat1, lon1, lat2, lon2) {
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const y = Math.sin(dLon) * Math.cos(lat2 * Math.PI / 180);
            const x = Math.cos(lat1 * Math.PI / 180) * Math.sin(lat2 * Math.PI / 180) -
                      Math.sin(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.cos(dLon);
            let bearing = Math.atan2(y, x) * 180 / Math.PI;
            return (bearing + 360) % 360;
        }

        // Determine if place is on left or right
        function getDirection(userHeading, bearingToPlace) {
            if (!userHeading) return null;
            
            let relativeBearing = bearingToPlace - userHeading;
            if (relativeBearing < 0) relativeBearing += 360;
            if (relativeBearing > 360) relativeBearing -= 360;
            
            // Within 45 degrees either side of straight ahead
            if (relativeBearing < 45 || relativeBearing > 315) return 'ahead';
            // Right side (45-135 degrees)
            if (relativeBearing >= 45 && relativeBearing < 135) return 'right';
            // Left side (225-315 degrees)  
            if (relativeBearing >= 225 && relativeBearing < 315) return 'left';
            // Behind (135-225 degrees)
            return 'behind';
        }

        // Generate varied announcement based on distance and direction
        function generateAnnouncement(placeName, summary, distance, direction) {
            const distKm = distance / 1000;
            let intro = '';
            
            if (distKm <= 0.05) {
                // Very close (50m or less)
                const phrases = [
                    direction === 'right' ? `On your right you'll see ${placeName}` :
                    direction === 'left' ? `On your left you'll see ${placeName}` :
                    direction === 'ahead' ? `Up ahead you'll see ${placeName}` :
                    `You are passing ${placeName}`,
                    
                    direction === 'right' ? `Coming up on your right, ${placeName}` :
                    direction === 'left' ? `Coming up on your left, ${placeName}` :
                    direction === 'ahead' ? `Straight ahead is ${placeName}` :
                    `You are near ${placeName}`,
                ];
                intro = phrases[Math.floor(Math.random() * phrases.length)];
            } else if (distKm <= 0.5) {
                // Medium distance (500m or less)
                const phrases = [
                    direction === 'right' ? `Approaching on your right, ${placeName}` :
                    direction === 'left' ? `Approaching on your left, ${placeName}` :
                    `You're approaching ${placeName}`,
                    
                    `Coming up soon, ${placeName}`,
                    `Up ahead you'll find ${placeName}`,
                ];
                intro = phrases[Math.floor(Math.random() * phrases.length)];
            } else {
                // Far (1km)
                const phrases = [
                    `You are near ${placeName}`,
                    `In the area is ${placeName}`,
                    `Nearby you'll find ${placeName}`,
                ];
                intro = phrases[Math.floor(Math.random() * phrases.length)];
            }
            
            return `${intro}. ${summary}`;
        }

        // Convert WGS84 coordinates to British National Grid (required for Historic England API)
        function wgs84ToBNG(lat, lon) {
            // This is a simplified approximation - for production use a proper library
            // But it's good enough for our radius search purposes
            const a = 6377563.396;
            const b = 6356256.909;
            const F0 = 0.9996012717;
            const lat0 = 49 * Math.PI / 180;
            const lon0 = -2 * Math.PI / 180;
            const N0 = -100000;
            const E0 = 400000;
            const e2 = 1 - (b*b)/(a*a);
            const n = (a-b)/(a+b);
            
            const latRad = lat * Math.PI / 180;
            const lonRad = lon * Math.PI / 180;
            
            const cosLat = Math.cos(latRad);
            const sinLat = Math.sin(latRad);
            
            const nu = a * F0 / Math.sqrt(1 - e2 * sinLat * sinLat);
            const rho = a * F0 * (1 - e2) / Math.pow(1 - e2 * sinLat * sinLat, 1.5);
            const eta2 = nu / rho - 1;
            
            const M = (b * F0) * (
                (1 + n + (5/4)*n*n + (5/4)*n*n*n) * (latRad - lat0) -
                (3*n + 3*n*n + (21/8)*n*n*n) * Math.sin(latRad - lat0) * Math.cos(latRad + lat0) +
                ((15/8)*n*n + (15/8)*n*n*n) * Math.sin(2*(latRad - lat0)) * Math.cos(2*(latRad + lat0)) -
                (35/24)*n*n*n * Math.sin(3*(latRad - lat0)) * Math.cos(3*(latRad + lat0))
            );
            
            const I = M + N0;
            const II = (nu/2) * sinLat * cosLat;
            const III = (nu/24) * sinLat * Math.pow(cosLat, 3) * (5 - Math.pow(Math.tan(latRad), 2) + 9*eta2);
            const IIIA = (nu/720) * sinLat * Math.pow(cosLat, 5) * (61 - 58*Math.pow(Math.tan(latRad), 2) + Math.pow(Math.tan(latRad), 4));
            
            const IV = nu * cosLat;
            const V = (nu/6) * Math.pow(cosLat, 3) * (nu/rho - Math.pow(Math.tan(latRad), 2));
            const VI = (nu/120) * Math.pow(cosLat, 5) * (5 - 18*Math.pow(Math.tan(latRad), 2) + Math.pow(Math.tan(latRad), 4) + 14*eta2 - 58*Math.pow(Math.tan(latRad), 2)*eta2);
            
            const dLon = lonRad - lon0;
            
            const northing = I + II*dLon*dLon + III*Math.pow(dLon, 4) + IIIA*Math.pow(dLon, 6);
            const easting = E0 + IV*dLon + V*Math.pow(dLon, 3) + VI*Math.pow(dLon, 5);
            
            return {easting: Math.round(easting), northing: Math.round(northing)};
        }

        // Fetch from Historic England API
        async function fetchHistoricEngland(lat, lon, searchRadius) {
            try {
                const bng = wgs84ToBNG(lat, lon);
                const url = `https://services-eu1.arcgis.com/ZOdPfBS3aqqDYPUQ/arcgis/rest/services/National_Heritage_List_for_England_NHLE_v02_VIEW/FeatureServer/0/query?` +
                    `geometry=${bng.easting},${bng.northing}&` +
                    `geometryType=esriGeometryPoint&` +
                    `inSR=27700&` +
                    `spatialRel=esriSpatialRelIntersects&` +
                    `distance=${searchRadius}&` +
                    `units=esriSRUnit_Meter&` +
                    `outFields=Name,Grade,ListEntry,CaptureCat&` +
                    `returnGeometry=true&` +
                    `outSR=4326&` +
                    `f=json`;
                
                addDebugMessage(`Querying Historic England API...`);
                
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                const features = data.features || [];
                
                // Filter for interesting buildings only
                const filteredFeatures = features.filter(f => {
                    const grade = f.attributes.Grade;
                    const name = (f.attributes.Name || '').toLowerCase();
                    const category = (f.attributes.CaptureCat || '').toLowerCase();
                    
                    // Only Grade I and II* (not Grade II)
                    if (grade !== 'I' && grade !== 'II*') {
                        return false;
                    }
                    
                    // Filter out boring building types
                    const boringTypes = ['house', 'cottage', 'barn', 'farmhouse', 'wall', 'gate', 
                                        'milestone', 'boundary', 'stable', 'shed', 'outbuilding'];
                    const hasBoring = boringTypes.some(type => 
                        name.includes(type) || category.includes(type)
                    );
                    
                    // Keep interesting types even if they match boring keywords
                    const interestingTypes = ['church', 'castle', 'abbey', 'priory', 'cathedral', 
                                             'museum', 'hall', 'manor', 'bridge', 'monument', 
                                             'tower', 'mill', 'palace', 'theatre'];
                    const hasInteresting = interestingTypes.some(type => 
                        name.includes(type) || category.includes(type)
                    );
                    
                    if (hasInteresting) return true;
                    if (hasBoring) return false;
                    
                    return true;
                });
                
                // Convert to format similar to Wikipedia
                const places = filteredFeatures.map(f => {
                    const dist = Math.sqrt(
                        Math.pow((f.geometry.x - lon) * 111320 * Math.cos(lat * Math.PI / 180), 2) +
                        Math.pow((f.geometry.y - lat) * 110574, 2)
                    );
                    
                    return {
                        title: f.attributes.Name || 'Historic Building',
                        lat: f.geometry.y,
                        lon: f.geometry.x,
                        dist: dist,
                        pageid: `he_${f.attributes.ListEntry}`,
                        grade: f.attributes.Grade,
                        listEntry: f.attributes.ListEntry,
                        source: 'historic_england'
                    };
                }).sort((a, b) => a.dist - b.dist);
                
                addDebugMessage(`Historic England: Found ${places.length} significant buildings (Grade I/II*)`);
                return places;
            } catch (error) {
                console.error('Historic England API error:', error);
                addDebugMessage(`Historic England error: ${error.message}`);
                return [];
            }
        }

        async function fetchNearbyPlaces(lat, lon, searchRadius) {
            try {
                // Just use Wikipedia for better, more interesting content
                const places = await fetchWikipedia(lat, lon, searchRadius);
                
                addDebugMessage(`Found ${places.length} places from Wikipedia`);
                foundCountEl.textContent = places.length;
                
                if (places.length > 0) {
                    places.slice(0, 5).forEach((p, i) => {
                        addDebugMessage(`${i+1}. ${p.title} - ${Math.round(p.dist)}m away`);
                    });
                }
                
                return places;
            } catch (error) {
                addDebugMessage(`ERROR: ${error.message}`);
                setStatus('Error fetching places', error.message);
                return [];
            }
        }

        async function fetchWikipedia(lat, lon, searchRadius) {
            try {
                const url = `https://en.wikipedia.org/w/api.php?action=query&list=geosearch&gscoord=${lat}|${lon}&gsradius=${searchRadius}&gslimit=15&format=json&origin=*`;
                
                const response = await fetch(url, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                    },
                    mode: 'cors'
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                const places = (data.query?.geosearch || []).map(p => ({
                    ...p,
                    lon: p.lon,
                    pageid: `wiki_${p.pageid}`,
                    source: 'wikipedia'
                }));
                
                return places;
            } catch (error) {
                console.error('Wikipedia API error:', error);
                addDebugMessage(`Wikipedia error: ${error.message}`);
                return [];
            }
        }

        async function fetchArticleSummary(place) {
            try {
                const pageId = place.pageid.replace('wiki_', '');
                const url = `https://en.wikipedia.org/w/api.php?action=query&prop=extracts&exintro=1&explaintext=1&pageids=${pageId}&format=json&origin=*`;
                
                const response = await fetch(url, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                    },
                    mode: 'cors'
                });
                
                const data = await response.json();
                const page = data.query.pages[pageId];
                
                if (page && page.extract) {
                    return extractInterestingFacts(page.extract);
                }
                
                return null;
            } catch (error) {
                console.error('Error fetching summary:', error);
                addDebugMessage(`Error getting summary: ${error.message}`);
                return null;
            }
        }

        // Extract the most interesting facts from Wikipedia text
        function extractInterestingFacts(text) {
            // Split into sentences
            const sentences = text.split(/\. |\.\n/).map(s => s.trim()).filter(s => s.length > 0);
            
            if (sentences.length === 0) return null;
            
            // Keywords that indicate interesting/notable facts
            const interestingKeywords = [
                'unique', 'only', 'first', 'oldest', 'largest', 'tallest', 'most',
                'famous', 'notable', 'significant', 'important', 'rare',
                'unesco', 'heritage', 'medieval', 'ancient', 'historic',
                'built in', 'dates from', 'founded', 'established',
                'grade i', 'grade ii', 'listed', 'designed by', 'birthplace',
                'battlefield', 'siege', 'victory', 'royal', 'king', 'queen',
                'rebellion', 'revolution', 'featured in', 'known for'
            ];
            
            // Score each sentence
            const scoredSentences = sentences.map(sentence => {
                const lower = sentence.toLowerCase();
                let score = 0;
                
                // Avoid overly long or short sentences
                if (sentence.length < 20 || sentence.length > 250) {
                    score -= 5;
                }
                
                // Check for interesting keywords
                interestingKeywords.forEach(keyword => {
                    if (lower.includes(keyword)) {
                        score += 3;
                    }
                });
                
                // Boost for "why it's significant" indicators
                if (lower.includes('known for') || lower.includes('famous for') || 
                    lower.includes('notable for') || lower.includes('significance')) {
                    score += 5;
                }
                
                // Avoid sentences with too many dates/numbers (usually boring details)
                const numberMatches = sentence.match(/\d{4}|\d+th century/g);
                if (numberMatches && numberMatches.length > 2) {
                    score -= 2;
                }
                
                // Avoid sentences that are just definitions or locations
                if (lower.startsWith('is a') || lower.startsWith('was a') || 
                    lower.includes('is located in') || lower.includes('is situated')) {
                    score -= 3;
                }
                
                // Prefer sentences with active verbs
                if (lower.includes('built') || lower.includes('designed') || 
                    lower.includes('created') || lower.includes('founded')) {
                    score += 1;
                }
                
                // Penalize overly technical language
                if (lower.includes('consists of') || lower.includes('comprises') || 
                    lower.includes('constructed of')) {
                    score -= 1;
                }
                
                return { sentence, score };
            });
            
            // Sort by score
            scoredSentences.sort((a, b) => b.score - a.score);
            
            // Take the highest scoring sentence
            const topSentences = scoredSentences.slice(0, 2);
            
            // If top sentence has negative score, just use first sentence
            if (topSentences[0].score < 0 && sentences.length > 0) {
                return sentences[0] + '.';
            }
            
            // If we have a good interesting sentence, use just that one
            if (topSentences[0].score >= 3) {
                return topSentences[0].sentence + '.';
            }
            
            // If we have two decent sentences, use both
            if (topSentences.length >= 2 && topSentences[1].score > 1) {
                return topSentences[0].sentence + '. ' + topSentences[1].sentence + '.';
            }
            
            // Fall back to just first sentence, cleaned up
            return sentences[0] + '.';
        }

        async function checkAndAnnounce(lat, lon, forceCheck = false) {
            const now = Date.now();
            
            if (!forceCheck && now - lastCheckTime < 10000) {
                return;
            }
            
            lastCheckTime = now;
            lastCheckEl.textContent = new Date().toLocaleTimeString();
            
            // First, do a wide search to determine density
            setStatus('Checking area density...');
            const densityCheck = await fetchNearbyPlaces(lat, lon, 2000);
            
            // Determine appropriate radius based on density
            let announceRadius;
            if (densityCheck.length >= 10) {
                announceRadius = 50;
                addDebugMessage('High density area - using 50m radius');
            } else if (densityCheck.length >= 5) {
                announceRadius = 500;
                addDebugMessage('Medium density area - using 500m radius');
            } else {
                announceRadius = 1000;
                addDebugMessage('Low density area - using 1km radius');
            }
            
            currentRadiusEl.textContent = `${announceRadius}m`;
            setStatus('Checking for nearby places...', `Using ${announceRadius}m radius`);
            
            // Now search with the appropriate radius
            const places = await fetchNearbyPlaces(lat, lon, announceRadius);
            
            if (places.length === 0) {
                setStatus('Listening for places...', 'No places found nearby');
                addDebugMessage('Check complete - nothing found');
                return;
            }
            
            let announced = false;
            
            for (const place of places) {
                const placeId = place.pageid.toString();
                
                if (announcedPlaces.has(placeId)) {
                    addDebugMessage(`${place.title} already announced`);
                    continue;
                }
                
                setStatus(`Found: ${place.title}`, `Distance: ${Math.round(place.dist)}m`);
                addDebugMessage(`Fetching info for ${place.title}...`);
                
                const summary = await fetchArticleSummary(place);
                
                if (summary) {
                    // Calculate direction
                    const bearingToPlace = calculateBearing(lat, lon, place.lat, place.lon);
                    const direction = getDirection(currentHeading, bearingToPlace);
                    
                    const announcement = generateAnnouncement(place.title, summary, place.dist, direction);
                    addToSpeechQueue(announcement);
                    addDebugMessage(`Announcing: ${place.title} (${direction || 'no heading'})`);
                    
                    addAnnouncement(place.title, 'wikipedia');
                    
                    announcedPlaces.add(placeId);
                    placeCountEl.textContent = announcedPlaces.size;
                    announced = true;
                    
                    break;
                } else {
                    addDebugMessage(`No summary available for ${place.title}`);
                }
            }
            
            if (!announced) {
                const msg = `No new places to announce (already covered or no summaries)`;
                setStatus('Listening for places...', msg);
                addDebugMessage(msg);
            }
        }

        function handleLocationUpdate(position) {
            currentLat = position.coords.latitude;
            currentLon = position.coords.longitude;
            currentHeading = position.coords.heading;
            
            locationEl.textContent = `${currentLat.toFixed(6)}, ${currentLon.toFixed(6)}`;
            
            if (currentHeading !== null && currentHeading !== undefined) {
                const directions = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
                const index = Math.round(currentHeading / 45) % 8;
                headingEl.textContent = `${Math.round(currentHeading)}Â° (${directions[index]})`;
            } else {
                headingEl.textContent = 'N/A (not moving)';
            }
            
            locationDiv.classList.remove('hidden');
            
            if (isActive) {
                checkAndAnnounce(currentLat, currentLon);
            }
        }

        function handleLocationError(error) {
            console.error('Location error:', error);
            setStatus(`Location error: ${error.message}`);
        }

        function startJourney() {
            if (!navigator.geolocation) {
                setStatus('Geolocation not supported');
                return;
            }
            
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    isActive = true;
                    setStatus('Journey started');
                    addToSpeechQueue('Journey started. I will tell you about places as you drive.');
                    
                    startBtn.classList.add('hidden');
                    checkBtn.classList.remove('hidden');
                    stopBtn.classList.remove('hidden');
                    
                    watchId = navigator.geolocation.watchPosition(
                        handleLocationUpdate,
                        handleLocationError,
                        {
                            enableHighAccuracy: true,
                            timeout: 5000,
                            maximumAge: 0
                        }
                    );
                },
                (error) => {
                    handleLocationError(error);
                }
            );
        }

        function manualCheck() {
            if (currentLat && currentLon) {
                setStatus('Manual check requested...');
                checkAndAnnounce(currentLat, currentLon, true);
            } else {
                setStatus('No location available yet');
            }
        }

        function stopJourney() {
            if (watchId !== null) {
                navigator.geolocation.clearWatch(watchId);
                watchId = null;
            }
            
            window.speechSynthesis.cancel();
            speechQueue = [];
            isProcessing = false;
            
            isActive = false;
            isSpeaking = false;
            setStatus('Journey ended');
            announcedPlaces = new Set();
            lastCheckTime = 0;
            placeCountEl.textContent = '0';
            foundCountEl.textContent = '0';
            currentRadiusEl.textContent = 'N/A';
            lastSourceEl.textContent = 'N/A';
            announcementListEl.innerHTML = '';
            recentAnnouncementsDiv.classList.add('hidden');
            
            speakingDiv.classList.add('hidden');
            startBtn.classList.remove('hidden');
            checkBtn.classList.add('hidden');
            stopBtn.classList.add('hidden');
        }

        startBtn.addEventListener('click', startJourney);
        checkBtn.addEventListener('click', manualCheck);
        stopBtn.addEventListener('click', stopJourney);
    </script>
</body>
</html>
