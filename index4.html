<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Driving Tour Guide</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .animate-pulse {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
    </style>
</head>
<body class="bg-gradient-to-b from-blue-50 to-blue-100 min-h-screen">
    <div class="p-4">
        <div class="max-w-md mx-auto">
            <div class="bg-white rounded-lg shadow-lg p-6 mb-4">
                <div class="flex items-center justify-center mb-6">
                    <svg class="w-8 h-8 text-blue-600 mr-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7"/>
                    </svg>
                    <h1 class="text-2xl font-bold text-gray-800">Driving Tour Guide</h1>
                </div>
                
                <div class="mb-6">
                    <div class="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-4">
                        <p class="text-sm text-blue-800 font-medium mb-2">Status:</p>
                        <p class="text-blue-900" id="status">Ready to start</p>
                        <p class="text-xs text-blue-700 mt-2" id="debugInfo"></p>
                    </div>
                    
                    <div id="locationDiv" class="bg-gray-50 border border-gray-200 rounded-lg p-4 mb-4 hidden">
                        <p class="text-sm text-gray-600 mb-1">Current Location:</p>
                        <p class="text-xs font-mono text-gray-700" id="location"></p>
                        <p class="text-xs text-gray-600 mt-1">Heading: <span id="heading">N/A</span></p>
                    </div>
                    
                    <div id="speakingDiv" class="flex items-center justify-center bg-green-50 border border-green-200 rounded-lg p-3 mb-4 hidden">
                        <svg class="w-5 h-5 text-green-600 mr-2 animate-pulse" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z"/>
                        </svg>
                        <p class="text-green-800 font-medium">Speaking...</p>
                    </div>
                    
                    <div class="bg-amber-50 border border-amber-200 rounded-lg p-4 mb-4">
                        <p class="text-sm text-amber-800 mb-1">
                            <strong>Places announced:</strong> <span id="placeCount">0</span>
                        </p>
                        <p class="text-xs text-amber-700 mt-1">
                            <strong>Places found nearby:</strong> <span id="foundCount">0</span>
                        </p>
                        <p class="text-xs text-amber-700 mt-1">
                            <strong>Current radius:</strong> <span id="currentRadius">N/A</span>
                        </p>
                        <p class="text-xs text-amber-700 mt-1">
                            <strong>Last check:</strong> <span id="lastCheck">Never</span>
                        </p>
                    </div>
                    
                    <div id="debugLog" class="bg-gray-50 border border-gray-300 rounded-lg p-3 mb-4 hidden">
                        <p class="text-xs font-bold text-gray-700 mb-1">Debug Log:</p>
                        <div id="debugMessages" class="text-xs text-gray-600 space-y-1 max-h-32 overflow-y-auto"></div>
                    </div>
                </div>
                
                <button id="startBtn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-4 px-6 rounded-lg flex items-center justify-center transition-colors mb-3">
                    <svg class="w-6 h-6 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"/>
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
                    </svg>
                    Start Journey
                </button>

                <button id="checkBtn" class="w-full bg-green-600 hover:bg-green-700 text-white font-semibold py-3 px-6 rounded-lg items-center justify-center transition-colors mb-3 hidden">
                    <svg class="w-5 h-5 mr-2 inline" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/>
                    </svg>
                    Check Now
                </button>
                
                <button id="stopBtn" class="w-full bg-red-600 hover:bg-red-700 text-white font-semibold py-4 px-6 rounded-lg items-center justify-center transition-colors hidden">
                    <svg class="w-6 h-6 mr-2 inline" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 10a1 1 0 011-1h4a1 1 0 011 1v4a1 1 0 01-1 1h-4a1 1 0 01-1-1v-4z"/>
                    </svg>
                    Stop Journey
                </button>
            </div>
            
            <div class="bg-white rounded-lg shadow-lg p-6">
                <h2 class="text-lg font-bold text-gray-800 mb-3">Instructions</h2>
                <ol class="text-sm text-gray-700 space-y-2">
                    <li>1. Connect your phone to your car via Bluetooth</li>
                    <li>2. Make sure your phone volume is turned up</li>
                    <li>3. Press "Start Journey" before you begin driving</li>
                    <li>4. Place your phone safely and keep it charging</li>
                    <li>5. The app will announce nearby historical places automatically</li>
                    <li>6. Use "Check Now" button to manually search for places</li>
                    <li>7. Press "Stop Journey" when you arrive</li>
                </ol>
                
                <div class="mt-4 bg-yellow-50 border border-yellow-200 rounded-lg p-3">
                    <p class="text-xs text-yellow-800">
                        <strong>Note:</strong> This app needs location permissions and internet connection. It works best with the phone plugged in to save battery. The app adapts its search radius based on area density.
                    </p>
                </div>
            </div>
        </div>
    </div>

    <script>
        let isActive = false;
        let watchId = null;
        let announcedPlaces = new Set();
        let lastCheckTime = 0;
        let isSpeaking = false;
        let speechQueue = [];
        let isProcessing = false;
        let currentLat = null;
        let currentLon = null;
        let currentHeading = null;

        const statusEl = document.getElementById('status');
        const debugInfoEl = document.getElementById('debugInfo');
        const locationEl = document.getElementById('location');
        const headingEl = document.getElementById('heading');
        const locationDiv = document.getElementById('locationDiv');
        const speakingDiv = document.getElementById('speakingDiv');
        const placeCountEl = document.getElementById('placeCount');
        const foundCountEl = document.getElementById('foundCount');
        const currentRadiusEl = document.getElementById('currentRadius');
        const lastCheckEl = document.getElementById('lastCheck');
        const debugLogDiv = document.getElementById('debugLog');
        const debugMessagesEl = document.getElementById('debugMessages');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const checkBtn = document.getElementById('checkBtn');

        function addDebugMessage(msg) {
            const timestamp = new Date().toLocaleTimeString();
            const msgEl = document.createElement('div');
            msgEl.textContent = `[${timestamp}] ${msg}`;
            debugMessagesEl.insertBefore(msgEl, debugMessagesEl.firstChild);
            debugLogDiv.classList.remove('hidden');
            console.log(msg);
            
            while (debugMessagesEl.children.length > 10) {
                debugMessagesEl.removeChild(debugMessagesEl.lastChild);
            }
        }

        function setStatus(msg, debug = '') {
            statusEl.textContent = msg;
            debugInfoEl.textContent = debug;
            console.log('Status:', msg, debug);
        }

        function speak(text) {
            return new Promise((resolve) => {
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.rate = 0.9;
                utterance.pitch = 1;
                utterance.volume = 1;
                
                utterance.onstart = () => {
                    console.log('Started speaking:', text.substring(0, 50));
                };
                
                utterance.onend = () => {
                    console.log('Finished speaking');
                    isSpeaking = false;
                    speakingDiv.classList.add('hidden');
                    resolve();
                };
                
                utterance.onerror = (e) => {
                    console.error('Speech error:', e);
                    isSpeaking = false;
                    speakingDiv.classList.add('hidden');
                    resolve();
                };
                
                isSpeaking = true;
                speakingDiv.classList.remove('hidden');
                window.speechSynthesis.cancel();
                window.speechSynthesis.speak(utterance);
            });
        }

        async function processSpeechQueue() {
            if (isProcessing || speechQueue.length === 0) {
                return;
            }
            
            isProcessing = true;
            
            while (speechQueue.length > 0) {
                const text = speechQueue.shift();
                await speak(text);
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
            
            isProcessing = false;
        }

        function addToSpeechQueue(text) {
            console.log('Adding to speech queue:', text.substring(0, 50));
            speechQueue.push(text);
            processSpeechQueue();
        }

        // Calculate bearing between two points
        function calculateBearing(lat1, lon1, lat2, lon2) {
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const y = Math.sin(dLon) * Math.cos(lat2 * Math.PI / 180);
            const x = Math.cos(lat1 * Math.PI / 180) * Math.sin(lat2 * Math.PI / 180) -
                      Math.sin(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.cos(dLon);
            let bearing = Math.atan2(y, x) * 180 / Math.PI;
            return (bearing + 360) % 360;
        }

        // Determine if place is on left or right
        function getDirection(userHeading, bearingToPlace) {
            if (!userHeading) return null;
            
            let relativeBearing = bearingToPlace - userHeading;
            if (relativeBearing < 0) relativeBearing += 360;
            if (relativeBearing > 360) relativeBearing -= 360;
            
            // Within 45 degrees either side of straight ahead
            if (relativeBearing < 45 || relativeBearing > 315) return 'ahead';
            // Right side (45-135 degrees)
            if (relativeBearing >= 45 && relativeBearing < 135) return 'right';
            // Left side (225-315 degrees)  
            if (relativeBearing >= 225 && relativeBearing < 315) return 'left';
            // Behind (135-225 degrees)
            return 'behind';
        }

        // Generate varied announcement based on distance and direction
        function generateAnnouncement(placeName, summary, distance, direction) {
            const distKm = distance / 1000;
            let intro = '';
            
            if (distKm <= 0.05) {
                // Very close (50m or less)
                const phrases = [
                    direction === 'right' ? `On your right you'll see ${placeName}` :
                    direction === 'left' ? `On your left you'll see ${placeName}` :
                    direction === 'ahead' ? `Up ahead you'll see ${placeName}` :
                    `You are passing ${placeName}`,
                    
                    direction === 'right' ? `Coming up on your right, ${placeName}` :
                    direction === 'left' ? `Coming up on your left, ${placeName}` :
                    direction === 'ahead' ? `Straight ahead is ${placeName}` :
                    `You are near ${placeName}`,
                ];
                intro = phrases[Math.floor(Math.random() * phrases.length)];
            } else if (distKm <= 0.5) {
                // Medium distance (500m or less)
                const phrases = [
                    direction === 'right' ? `Approaching on your right, ${placeName}` :
                    direction === 'left' ? `Approaching on your left, ${placeName}` :
                    `You're approaching ${placeName}`,
                    
                    `Coming up soon, ${placeName}`,
                    `Up ahead you'll find ${placeName}`,
                ];
                intro = phrases[Math.floor(Math.random() * phrases.length)];
            } else {
                // Far (1km)
                const phrases = [
                    `You are near ${placeName}`,
                    `In the area is ${placeName}`,
                    `Nearby you'll find ${placeName}`,
                ];
                intro = phrases[Math.floor(Math.random() * phrases.length)];
            }
            
            return `${intro}. ${summary}`;
        }

        async function fetchNearbyPlaces(lat, lon, searchRadius) {
            try {
                const url = `https://en.wikipedia.org/w/api.php?action=query&list=geosearch&gscoord=${lat}|${lon}&gsradius=${searchRadius}&gslimit=15&format=json&origin=*`;
                
                addDebugMessage(`Searching at ${lat.toFixed(4)}, ${lon.toFixed(4)} with ${searchRadius}m radius`);
                
                const response = await fetch(url, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                    },
                    mode: 'cors'
                });
                
                addDebugMessage(`API response status: ${response.status}`);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                const places = data.query?.geosearch || [];
                
                addDebugMessage(`Found ${places.length} places in ${searchRadius}m radius`);
                foundCountEl.textContent = places.length;
                
                if (places.length > 0) {
                    places.forEach((p, i) => {
                        if (i < 5) {
                            addDebugMessage(`${i+1}. ${p.title} - ${p.dist}m away`);
                        }
                    });
                } else {
                    addDebugMessage('No Wikipedia entries found nearby');
                }
                
                return places;
            } catch (error) {
                addDebugMessage(`ERROR: ${error.message}`);
                setStatus('Error fetching places', error.message);
                return [];
            }
        }

        async function fetchArticleSummary(pageId) {
            try {
                const url = `https://en.wikipedia.org/w/api.php?action=query&prop=extracts&exintro=1&explaintext=1&pageids=${pageId}&format=json&origin=*`;
                
                const response = await fetch(url, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                    },
                    mode: 'cors'
                });
                
                const data = await response.json();
                const page = data.query.pages[pageId];
                
                if (page && page.extract) {
                    const sentences = page.extract.split('. ').slice(0, 3).join('. ');
                    return sentences + (sentences.endsWith('.') ? '' : '.');
                }
                
                return null;
            } catch (error) {
                console.error('Error fetching summary:', error);
                addDebugMessage(`Error getting summary: ${error.message}`);
                return null;
            }
        }

        async function checkAndAnnounce(lat, lon, forceCheck = false) {
            const now = Date.now();
            
            if (!forceCheck && now - lastCheckTime < 10000) {
                return;
            }
            
            lastCheckTime = now;
            lastCheckEl.textContent = new Date().toLocaleTimeString();
            
            // First, do a wide search to determine density
            setStatus('Checking area density...');
            const densityCheck = await fetchNearbyPlaces(lat, lon, 2000);
            
            // Determine appropriate radius based on density
            let announceRadius;
            if (densityCheck.length >= 10) {
                announceRadius = 50;
                addDebugMessage('High density area - using 50m radius');
            } else if (densityCheck.length >= 5) {
                announceRadius = 500;
                addDebugMessage('Medium density area - using 500m radius');
            } else {
                announceRadius = 1000;
                addDebugMessage('Low density area - using 1km radius');
            }
            
            currentRadiusEl.textContent = `${announceRadius}m`;
            setStatus('Checking for nearby places...', `Using ${announceRadius}m radius`);
            
            // Now search with the appropriate radius
            const places = await fetchNearbyPlaces(lat, lon, announceRadius);
            
            if (places.length === 0) {
                setStatus('Listening for places...', 'No places found nearby');
                addDebugMessage('Check complete - nothing found');
                return;
            }
            
            let announced = false;
            
            for (const place of places) {
                const placeId = place.pageid.toString();
                
                if (announcedPlaces.has(placeId)) {
                    addDebugMessage(`${place.title} already announced`);
                    continue;
                }
                
                setStatus(`Found: ${place.title}`, `Distance: ${place.dist}m`);
                addDebugMessage(`Fetching info for ${place.title}...`);
                
                const summary = await fetchArticleSummary(place.pageid);
                
                if (summary) {
                    // Calculate direction
                    const bearingToPlace = calculateBearing(lat, lon, place.lat, place.lon);
                    const direction = getDirection(currentHeading, bearingToPlace);
                    
                    const announcement = generateAnnouncement(place.title, summary, place.dist, direction);
                    addToSpeechQueue(announcement);
                    addDebugMessage(`Announcing: ${place.title} (${direction || 'no heading'})`);
                    
                    announcedPlaces.add(placeId);
                    placeCountEl.textContent = announcedPlaces.size;
                    announced = true;
                    
                    break;
                } else {
                    addDebugMessage(`No summary available for ${place.title}`);
                }
            }
            
            if (!announced) {
                const msg = `No new places to announce (already covered or no summaries)`;
                setStatus('Listening for places...', msg);
                addDebugMessage(msg);
            }
        }

        function handleLocationUpdate(position) {
            currentLat = position.coords.latitude;
            currentLon = position.coords.longitude;
            currentHeading = position.coords.heading;
            
            locationEl.textContent = `${currentLat.toFixed(6)}, ${currentLon.toFixed(6)}`;
            
            if (currentHeading !== null && currentHeading !== undefined) {
                const directions = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
                const index = Math.round(currentHeading / 45) % 8;
                headingEl.textContent = `${Math.round(currentHeading)}Â° (${directions[index]})`;
            } else {
                headingEl.textContent = 'N/A (not moving)';
            }
            
            locationDiv.classList.remove('hidden');
            
            if (isActive) {
                checkAndAnnounce(currentLat, currentLon);
            }
        }

        function handleLocationError(error) {
            console.error('Location error:', error);
            setStatus(`Location error: ${error.message}`);
        }

        function startJourney() {
            if (!navigator.geolocation) {
                setStatus('Geolocation not supported');
                return;
            }
            
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    isActive = true;
                    setStatus('Journey started');
                    addToSpeechQueue('Journey started. I will tell you about places as you drive.');
                    
                    startBtn.classList.add('hidden');
                    checkBtn.classList.remove('hidden');
                    stopBtn.classList.remove('hidden');
                    
                    watchId = navigator.geolocation.watchPosition(
                        handleLocationUpdate,
                        handleLocationError,
                        {
                            enableHighAccuracy: true,
                            timeout: 5000,
                            maximumAge: 0
                        }
                    );
                },
                (error) => {
                    handleLocationError(error);
                }
            );
        }

        function manualCheck() {
            if (currentLat && currentLon) {
                setStatus('Manual check requested...');
                checkAndAnnounce(currentLat, currentLon, true);
            } else {
                setStatus('No location available yet');
            }
        }

        function stopJourney() {
            if (watchId !== null) {
                navigator.geolocation.clearWatch(watchId);
                watchId = null;
            }
            
            window.speechSynthesis.cancel();
            speechQueue = [];
            isProcessing = false;
            
            isActive = false;
            isSpeaking = false;
            setStatus('Journey ended');
            announcedPlaces = new Set();
            lastCheckTime = 0;
            placeCountEl.textContent = '0';
            foundCountEl.textContent = '0';
            currentRadiusEl.textContent = 'N/A';
            
            speakingDiv.classList.add('hidden');
            startBtn.classList.remove('hidden');
            checkBtn.classList.add('hidden');
            stopBtn.classList.add('hidden');
        }

        startBtn.addEventListener('click', startJourney);
        checkBtn.addEventListener('click', manualCheck);
        stopBtn.addEventListener('click', stopJourney);
    </script>
</body>
</html>
